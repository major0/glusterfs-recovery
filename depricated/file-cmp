#!/bin/sh
#set -e

## error
# Display an error message on stderr
error() { echo "error: $*" >&2; }

## die
# Display an error message on stderr and terminate execution
die() { echo "error: $*" >&2; exit 1; }

## usage
usage()
{
	: "usage($*)"
	if test "$#" -gt '0'; then
		error "$*"
		echo "try '$0 --help'" >&2
		exit 1
	fi
	echo "usage: $0 <volume> <node> [/path/to/backup]" >&2
	exit 0
}

## volume_is_valid
# @1 volume name
volume_is_valid() { gluster volume list|grep -q "^${1}$"; }

## brick_path
# @1 volume name
# @2 node
# Find the brick path for a given node
brick_path()
{(
	: "brick_path($*)"
	__brick_path_volume="${1}"
	__brick_path_node="${2}"
	gluster volume status "${__brick_path_volume}"|while read __brick_path_line; do
		set -- ${__brick_path_line}
		case "${1}" in
		(Brick*)
			set -- "${2%%:*}" "${2#*:}"
			if test "${1}" = "${__brick_path_node}"; then
				echo "${2#*:}"
				exit 0
			fi
			continue
			;;
		esac
	done
	exit 0
)}

## file_from_inum
# @1 brick path
# @2 inum
file_from_inum()
{
	: "file_from_inum($*)"
	find "${1}" -inum "${2}" ! -path '*/.glusterfs/*'|sed -e "s,^${1},,"
}

## file_from_gfid
# @1 brick path
# @2 gfid
#
# The .glusterfs directory in the brick root has files named by GFIDs.
#   IF: The GFID identifies a directory, then this file is a symlink to the actual
#       directory.
#   IF: The GFID identifies a file, then this file is a hard-link to the actual file.
file_from_gfid()
{
	: "file_from_gfid($*)"
	set -- "${1}" "${2}" "${2%${2##????}}"
	set -- "${1}" "${2}" "${1}/.glusterfs/${3%??}/${3#??}"
	set -- "$@" "${3}/${2}"
	# @1 brick path
	# @2 gfid
	# @3 gfid_prefix
	# @4 gfid_path
	test -e "${4}" || die "no such file or directory '${4}'"

	if test -h "${4}"; then
		realpath "${3}/$(readlink "${4}")"
	else
		set -- "$@" "$(stat --printf='%i' "${4}")"
		file_from_inum "${1}"  "${5}"
	fi
}

## heal_list
# @1 volume to examine
# @2 hostname to use for the local node
heal_list()
{
	: "heal_list($*)"
	__heal_list_volume="${1}"
	__heal_list_hostname="${2}"
	# pipes spawn a subshell
	export __heal_list_hostname

	gluster volume heal "${__heal_list_volume}" info | while read __heal_list_line; do
		test -n "${__heal_list_line}" || continue
		case "${__heal_list_line}" in
		(Brick*:*)
			: "__heal_list_line='$*'"
			set -- ${__heal_list_line}

			case "${2}" in
			(${__heal_list_hostname}:*)
				__heal_list_brick="${2##*:}";;
			(*)	__heal_list_brick=
				continue;;
			esac

			test -d "${__heal_list_brick}" || die "local brick not found '${__heal_list_brick}'"
			continue
			;;
		esac

		test -n "${__heal_list_brick}" || continue

		case "${__heal_list_line}" in
		(*gfid:*)
			__heal_list_head="${__heal_list_line##*:}"
			__heal_list_tail="${__heal_list_head#*/}"
			if test "${__heal_list_head}" != "${__heal_list_tail}"; then
				__heal_list_head="${__heal_list_head%${__heal_list_tail}}/${__heal_list_tail}"
			else
				__heal_list_head="${__heal_list_head%>}"
			fi
			file_from_gfid "${__heal_list_brick}" "${__heal_list_head}"
			;;

		(Status:*|Number*of*entries:*)
			continue;;

		(*)
			# note: there appears to be a bug in the gluster tools
			# which appends whitespace to the file name
			printf '%s\n' "${__heal_list_line%% }";;
		esac
	done
	unset __heal_list_volume
	unset __heal_list_hostname
}

## file_cmp
# @1 /path/to/local/brick
# @2 host:/path/to/remote/brick
# @3 optional /path/to/backup
file_cmp()
{
	: "file_cmp($*)"
	__file_cmp_local_path="${1}"
	__file_cmp_remote_host="${2%%:*}"
	__file_cmp_remote_path="${2#*:}"
	__file_cmp_backup_path="${3}"

	while read __file_cmp_line; do
		__file_cmp_backup_size=0
		__file_cmp_remote_size=0
		__file_cmp_local_size=0
		if test -e "${__file_cmp_local_path}${__file_cmp_line}"; then
			__file_cmp_local_size="$(stat --printf='%s' "${__file_cmp_local_path}${__file_cmp_line}" 2>/dev/null)"
		fi
		if test -e "${__file_cmp_backup_path}${__file_cmp_line}"; then
			__file_cmp_backup_size="$(stat --printf='%s' "${__file_cmp_backup_path}${__file_cmp_line}")"
		fi
		if rtest "${__file_cmp_remote_host}" -e "\"${__file_cmp_remote_path}${__file_cmp_line}\""; then
			__file_cmp_remote_size="$(rstat "${__file_cmp_remote_host}" --printf='%s' "\"${__file_cmp_remote_path}${__file_cmp_line}\"")"
		fi
		if test "${__file_cmp_local_size}" -eq "${__file_cmp_remote_size}"; then
			if test "${__file_cmp_local_size}" -gt '0'; then
				! ${VERBOSE} || echo "OK:${__file_cmp_line}"
			else
				! ${VERBOSE} || echo "!:${__file_cmp_line}"
				continue
			fi
		elif test "${__file_cmp_local_size}" -gt "${__file_cmp_remote_size}"; then
			! ${VERBOSE} || printf '%d>%d:%s\n' "${__file_cmp_local_size}" "${__file_cmp_remote_size}" "${__file_cmp_line}"
		elif test "${__file_cmp_backup_size}" -gt "${__file_cmp_remote_size}"; then
			! ${VERBOSE} || printf '%d>%d:%s\n' "${__file_cmp_local_size}" "${__file_cmp_remote_size}" "${__file_cmp_line}"
		else
			! ${VERBOSE} || printf '%d<%d:%s\n' "${__file_cmp_local_size}" "${__file_cmp_remote_size}" "${__file_cmp_line}"
		fi
	done
	unset __file_cmp_backup_size
	unset __file_cmp_remote_size
	unset __file_cmp_local_size
	unset __file_cmp_local_path
	unset __file_cmp_remote_host
	unset __file_cmp_remote_path
	unset __file_cmp_backup_path
}

## rtest
# @1 host
# ... args to remote test
rtest()
{
	: "rtest($*)"
	__rtest_remote_host="${1}"
	shift
	set -- $(ssh -n -T -o PasswordAuthentication=no "${__rtest_remote_host}" "STRING_ERR=\"\$(test "$@" 2>&1 1>/dev/null)\";echo \"\$? \${STRING_ERR}\"")
	__rtest_return="${1}"
	shift 1
	test "$#" -eq 0 || echo "$*" >&2
	set -- ${__rtest_return}
	unset __rtest_remote_host
	unset __rtest_return
	return $1
}

## rstat
# @1 host
# ... args to remote stat
rstat()
{
	: "rstat($*)"
	__rstat_remote_host="${1}"
	shift
	set -- $(ssh -n -T -o PasswordAuthentication=no "${__rstat_remote_host}" "STRING_OUT=\"\$(stat "$@" 2>/dev/null)\";printf \"\$? \${STRING_OUT}\"")
	__rstat_return="${1}"
	shift 1
	echo "$*"
	set -- ${__rstat_return}
	unset __rstat_remote_host
	unset __rstat_return
	return $1
}



# Argument handling
VERBOSE='true'
for arg; do case "${arg}" in (-h|--help) usage;;esac;done
while test "$#" -gt "0"; do
	case "${1}" in
	(-H|--hostname)	HOSTNAME="${2}";shift 2;;
	(-v|--verbose)	VERBOSE='true';shift;;
	# Basic posix conformance
	(-*)	usage "unknown argument '${1}'";;
	(--)	shift; break;; # Start parsing on '--'
	(*)	break;;	# Break on unknown arguments
	esac
done
export VERBOSE

test -n "${HOSTNAME}" || HOSTNAME="$(hostname)"
export HOSTNAME

gluster volume list > /dev/null 2>&1 || die "'gluster' command unavailable"

test "$#" -gt 0 || usage 'no volume specified'
volume_is_valid "${1}" || die "invalid volume '${1}'"
VOLUME="${1}"
shift

test "$#" -gt 0 || usage 'no remote node specified'
if ! ssh -n -T -o PasswordAuthentication=no "${1}" exit 0; then
	die "localhost not authorized to ssh to '${1}'"
fi
REMOTE_HOST="${1}"
shift

if test "$#" -gt 0; then
	test -d "${1}" || die "invalid directory '${1}'"
	BACKUP_PREFIX="$1";shift
fi

LOCAL_PREFIX="$(brick_path "${VOLUME}" "${HOSTNAME}")"
REMOTE_PREFIX="$(brick_path "${VOLUME}" "${REMOTE_HOST}")"

heal_list "${VOLUME}" "${HOSTNAME}" | file_cmp "${LOCAL_PREFIX}" "${REMOTE_HOST}:${REMOTE_PREFIX}" ${BACKUP_PREFIX}
